# JavaScript 教程

[完整文档地址](http://wangdoc.com/javascript/basic/history.html)

> 以问答形式记录我认为的关键点

## 入门篇

### 导论

Q1.1.1 什么是脚本语言？

`这种语言本身不具备开发操作系统的能力，用来编写和控制其他大型应用程序（宿主）的"脚本"。`

Q1.1.2 什么是嵌入式语言？

`这种语言本身核心的语法并不多，主要靠宿主环境提供API来实现功能，所以更适合嵌入到其他框架。`

Q1.1.3 JavaScript的核心语法部分包括哪两个部分？

`基本的语法构造 和 标准库。`

Q1.1.4 以浏览器为例，它提供的API可以分为哪三类？

* 浏览器控制类：操作浏览器
* DOM类：操作网页的各种元素
* Web类：实现互联网的各种功能

Q1.1.5 请举出以JavaScript为基础的其他语言，至少三种。

`CoffeeScript, TypeScript, Dart`

Q1.1.6 WebAssembly 格式是怎么来的？

`JavaScript 引擎（V8）的中间码格式，全部都是二进制代码。C/C++可以编译成这种格式。`

Q1.1.7 关于Chrome的实验环境，如何使得代码换行而不触发执行？

`Shift + Enter`

### 历史

Q1.2.1 JavaScript 之父 Brendan Eich 在开发第一个版本时，借鉴了哪些语法涞源？

* 基本语法：借鉴 C 语言和 Java 语言。
* 数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。
* 函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。
* 原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。
* 正则表达式：借鉴 Perl 语言。
* 字符串和数组处理：借鉴 Python 语言。

### 基本语法

Q1.3.1 语句与表达式的区别？

`语句是实现某种操作，而表达式是得到一个结果。`

Q1.3.2 JavaScript 变量名是否区分大小写？

`会区分大小写。`

Q1.3.3 var在哪些地方有别于ES6的const，let？

`var可以重复声明（第二次声明无效）而不报错，并且声明会被提升`

Q1.3.3' const,let是如何实现的？

`可以通过babel看它的转译，在此之前，可以自己先想想`

Q1.3.4 switch语句内部采用的是哪种“相等运算符”？

`===，严格相等运算符`

Q1.3.5 标签有什么用？

`类似break，continue语句可以跳出多重循环或代码块`

## 数据类型

### 概述

Q2.1.1 JavaScript的数据类型树？

`三种原始类型：数值，字符串，布尔值；两个特殊值：undefined, null；一个对象（狭义的对象；数组；函数）`

Q2.1.2 广义的对象和狭义的对象有什么区别？

`一种解释里，把complex type 译为 合成类型（权威指南译：复杂类型）。广义的对象包括：狭义的对象，数组以及函数`

Q2.1.3 JavaScript有三种方法确定一个值的类型, 哪三种？

`typeof, instanceof, Object.prototye.toString`

Q2.1.4 typeof的优缺点？

``` javascript
优点：可以检查一个没有声明的变量而不报错
缺点：无法区分对象里的数组与狭义的对象以及null的区别（instanceof可以）
```

### null, undefined 和布尔值

Q2.2.1 null和undefined在数字的转换上有什么不同？

`null会处理成0，而undefined会被处理成NaN`

Q2.2.2 对于undefined，需要注意的地方？

`它表示的是“为定义”，因此不应把它作为初始值变量赋值。在Dart语言中就不存在undefined`

Q2.2.3 哪些值是“假值”？

`null, undefined, "", '', 0, (NaN)`

### 数值

Q2.3.1 1和1.0在===上相等吗？

`相等哦～ 因为所有数字最终都是以64位浮点数形式存储的`

Q2.3.2 64位浮点数的实际存储形式？

``` javascript
国际标准 IEEE 754
规定：如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。
存储结构：
  .第1位：符号位，0表示正数，1表示负数
  .第2位到第12位（共11位）：指数部分
  .第13位到第64位（共52位）：小数部分（即有效数字）
计算公式：(-1)^符号位 * 1.xx...xx * 2^指数部分
有效数字个数决定了它能保证的精度度，在整数的精准度在-2^53到2^53（这里的53是加上前面那个1）
const i = 9007199254740992111 // 实际显示9007199254740992000
```

Q2.3.1. 64位浮点数的边界范围？

`由于指数部分11位，即0～2047，其中一半表示负数，所以数值范围是2^1024到-2^1024(开区间)，另外最小能表示的数2^-1075(小数部分的52位)`

Q2.3.2 什么时候会数字会自动编程科学计数法显示？

`小数点前的数字多于21位；小数点后的零多于5个`

Q2.3.3 JavaScript对于多大的十进制可以精确计算？

`15位及以内的十进制数（16位并不是全部），由2^53计算得到`

Q2.3.4 -0 与 +0 在哪种场合下不等价？

`当作为分母的时候`

Q2.3.5. Infinity > NaN 返回什么？ 那Infinity < NaN，这样又返回什么？

`都返回false`

Q2.3.6. 0 * Infinity返回什么？

``` javascript
NaN
与之类似的还有：
Infinity - Infinity // NaN
Infinity / Infinity // NaN
```

Q2.3.7 parseInt(1000000000000000000000.5) ，结果返回什么？

`1（注意parseInt的参数是字符串，所以对于任何参数都会先转换成字符串再进行下一步处理；第一位可以是正负符号位）`

Q2.3.8 parseInt('+011') ，结果返回什么？

`11, 只有十六进制的"0x"，"0X"会进行特殊处理，其他都按照10进制完成（如果需要按照2～36进制进行解读，需要用到第二个参数）`

Q2.3.9. String(0x11), 输出是什么？

`"17",因为优先是对这个格式进行十进制处理，或者科学计数法处理`

Q2.3.10. pareseFloat能否处理符合科学计数法的字符串？

`可以，会自动获取空格`

Q2.3.11. pareseFloat能否处理符合科学计数法的字符串？

`可以，会自动获取空格`

### 字符串

Q21. console.log('你好，世界'.length)，输入什么？

`5, 大部分中文字符已经纳入一个字符，但是依旧存在一些字符在浏览器上是一个字符，而javascript存储为2个字符`

Q22. Base64转码的两个原生方法？

`btoa, atob:前者转为Base64编码，后者反编译回去。`

Q23. 对于非 ASCII 码字符转 Base64 编码，如何处理？

``` javascript
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"
```

### 对象

Q24. { foo: 123 }, 这是表达式还是语句？

`如果无法确定是对象还是代码块，一律会被解释成代码块【解释成对象，需要加小括号（必然被认为是表达式处理）】`

Q25. 用in判断对应是否存在属性a有什么不足的地方？

`无法区分这个属性是自己的（hasOwnProperty），还是继承过来的`

Q26. 什么情况下delete操作会返回false？

`该对象有该属性，但是因为Object.defineProperty设置，该属性无法删除的时候。`

Q27. 为什么没人用 with 语句？

`它无法确定语句块内的变量是对应with的对象，还是全局变量，不便于自动检测。`

### 函数

Q28. 函数表达式写的函数名和function命令的函数名有啥区别？

`前者只能在函数内部使用。`

Q29. 如果重复声明函数，前一次声明在什么时候起作用？

`任何时候都是无效的。因为函数声明会被提前`

Q30. 第一等公民指的是？

`函数，因为它被看作一种值。`

Q31. 如下输出结果是？

```javascript
var f = function () {
  console.log('1');
}

function f() {
  console.log('2');
}

f()
```

`1`

Q32. name, length, toString 哪个参数可以实现面向对象编程的“方法重载”？

`length`

Q33. 如下输出结果是？

```javascript
var obj = [1, 2, 3];

function f(o) {
  o = [2, 3, 4];
}
f(obj);
```

`[1,2,3]`

Q34. 函数里的参数同名，会怎样？

`后者覆盖前者`

Q35. 函数内部的默认变量如何获取？

`通过访问它的原型prototype`

Q36. 如何理解函数里的call与apply，以及bind？

`call(参数列表)， apply(参数数组)：当你想把一个对象的方法给另外一个没有这个方法的对象使用的时候；bind：当你想把一个方法从一个对象里拿出来单独使用的时候`

Q37. 请用一句话说清楚闭包。

`链式作用域导致函数内部的变量无法被外部访问，闭包就是这个函数内部的一个函数，用于链接函数内部变量的桥梁。`

`每次调用都会生成一个新的闭包，保存诞生的环境，形成缓存，会占用内存。`

Q38. 请解释以下情况：

```javascript
function(){ /* code */ }();
// SyntaxError: Unexpected token (

var f = function f() {console.log('hello baby')}()
// hello baby
```

`function这个关键字即可以当作语句，也可以当作表达式。`

```javascript
// 语句
function f() {}

// 表达式
var f = function f() {}
```

`为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。`