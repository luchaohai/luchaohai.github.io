# JavaScript 教程

> 以问答形式记录关键点

## 入门篇

### 导论

### 历史

### 基本语法

Q1. 语句与表达式的区别？

`语句是实现某种操作，而表达式是得到一个结果`

Q2. var在哪些地方有别于ES6的const，let？

`var可以重复声明而不报错，并且声明会被提升`

Q3. switch语句内部采用的是哪种“相等运算符”？

`===，严格相等运算符`

Q4. 标签有什么用？

`类似break，continue语句可以跳出多重循环或代码块`

## 数据类型

### 概述

Q5. 原始类型其实只有三种，哪三种？

`数值，字符串，布尔值`

Q6. 广义的对象和狭义的对象有什么区别？

`一种解释里，把complex type 译为 合成类型。广义的对象包括：狭义的对象，数组以及函数`

Q7. undefined,null 是原始类型还是合成类型（复杂类型）？

`都不是，只是两个特殊值`

Q8. typeof的优缺点？

``` javascript
优点：可以检查一个没有声明的变量而不报错
缺点：无法区分对象里的数组与狭义的对象以及null的区别（instanceof可以）
```

### null, undefined 和布尔值

Q9. null和undefined在数字的转换上有什么不同？

`null会处理成0，而undefined会被处理成NaN`

Q10. 对于undefined，需要注意的地方？

`它表示的是“为定义”，因此不应把它作为初始值变量赋值`

Q11. 哪些值是“假值”？

`null, undefined, "", '', 0, (NaN)`

### 数值

Q12. 1和1.0在===上相等吗？

`相等哦～ 因为所有数字最终都是以64位浮点数形式存储的`

Q13. 64位浮点数的实际存储形式？

``` javascript
国际标准 IEEE 754
规定：如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。
存储结构：
  .第1位：符号位，0表示正数，1表示负数
  .第2位到第12位（共11位）：指数部分
  .第13位到第64位（共52位）：小数部分（即有效数字）
计算公式：(-1)^符号位 * 1.xx...xx * 2^指数部分
有效数字个数决定了它能保证的精度度，在整数的精准度在-2^53到2^53（这里的53是加上前面那个1）
const i = 9007199254740992111 // 实际显示9007199254740992000
```

Q14. 64位浮点数最大表示的数值？

`由于指数部分11位，即0～2047，其中一半表示负数，所以数值范围是2^1024到2^-1024(开区间)`

Q15. 什么时候会数字会自动编程科学计数法显示？

`小数点前的数字多于21位；小数点后的零多于5个`

Q16. -0 与 +0 在哪种场合下不等价？

`当作为分母的时候`

Q17. Infinity > NaN 返回什么？ 那Infinity < NaN，这样又返回什么？

`都返回false`

Q18. 0 * Infinity返回什么？

``` javascript
NaN
与之类似的还有：
Infinity - Infinity // NaN
Infinity / Infinity // NaN
```

Q19. parseInt(1000000000000000000000.5) ，结果返回什么？

`1`

Q20. String(0x11), 输出是什么？

`"17",因为优先是对这个格式进行十进制处理，或者科学计数法处理`

### 字符串

Q21. console.log('你好，世界'.length)，输入什么？

`5, 大部分中文字符已经纳入一个字符，但是依旧存在一些字符在浏览器上是一个字符，而javascript存储为2个字符`

Q22. Base64转码的两个原生方法？

`btoa, atob:前者转为Base64编码，后者反编译回去。`

Q23. 对于非 ASCII 码字符转 Base64 编码，如何处理？

``` javascript
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"
```

### 对象

Q24. { foo: 123 }, 这是表达式还是语句？

`如果无法确定是对象还是代码块，一律会被解释成代码块【解释成对象，需要加小括号（必然被认为是表达式处理）】`

Q25. 用in判断对应是否存在属性a有什么不足的地方？

`无法区分这个属性是自己的（hasOwnProperty），还是继承过来的`

Q26. 什么情况下delete操作会返回false？

`该对象有该属性，但是因为Object.defineProperty设置，该属性无法删除的时候。`

Q27. 为什么没人用 with 语句？

`它无法确定语句块内的变量是对应with的对象，还是全局变量，不便于自动检测。`

### 函数

Q28. 函数表达式写的函数名和function命令的函数名有啥区别？

`前者只能在函数内部使用。`

Q29. 如果重复声明函数，前一次声明在什么时候起作用？

`任何时候都是无效的。因为函数声明会被提前`

Q30. 第一等公民指的是？

`函数，因为它被看作一种值。`

Q31. 如下输出结果是？

```javascript
var f = function () {
  console.log('1');
}

function f() {
  console.log('2');
}

f()
```

`1`

Q32. name, length, toString 哪个参数可以实现面向对象编程的“方法重载”？

`length`

Q33. 如下输出结果是？

```javascript
var obj = [1, 2, 3];

function f(o) {
  o = [2, 3, 4];
}
f(obj);
```

`[1,2,3]`

Q34. 函数里的参数同名，会怎样？

`后者覆盖前者`

Q35. 函数内部的默认变量如何获取？

`通过访问它的原型prototype`

Q36. 如何理解函数里的call与apply，以及bind？

`call(参数列表)， apply(参数数组)：当你想把一个对象的方法给另外一个没有这个方法的对象使用的时候；bind：当你想把一个方法从一个对象里拿出来单独使用的时候`

Q37. 请用一句话说清楚闭包。

`链式作用域导致函数内部的变量无法被外部访问，闭包就是这个函数内部的一个函数，用于链接函数内部变量的桥梁。`

`每次调用都会生成一个新的闭包，保存诞生的环境，形成缓存，会占用内存。`

Q38. 请解释以下情况：

```javascript
function(){ /* code */ }();
// SyntaxError: Unexpected token (

var f = function f() {console.log('hello baby')}()
// hello baby
```

`function这个关键字即可以当作语句，也可以当作表达式。`

```javascript
// 语句
function f() {}

// 表达式
var f = function f() {}
```

`为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。`